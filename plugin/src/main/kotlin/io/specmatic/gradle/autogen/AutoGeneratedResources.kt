package io.specmatic.gradle.autogen

import io.specmatic.gradle.SpecmaticGradlePlugin
import io.specmatic.gradle.versioninfo.AUTO_GENERATED_CODE_WARNING
import io.specmatic.gradle.versioninfo.ProjectVersionInfo
import io.specmatic.gradle.versioninfo.kotlinPackage
import io.specmatic.gradle.versioninfo.kotlinPackageDir
import java.io.File
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.tasks.Delete
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.SourceSetContainer
import org.gradle.api.tasks.TaskProvider

internal fun Project.generatedResourcesDir(): File = file("src/main/gen-resources")

internal fun Project.generatedKotlinSourcesDir(): File = file("src/main/gen-kt")

internal fun Project.registerAutoGeneratedKotlinSourceTask(vararg tasks: Any?) {
    project.getOrCreateAutoGenerateKotlinSourcesTask().configure {
        dependsOn(tasks)
    }
}

internal fun Project.registerAutoGeneratedResourcesTask(vararg tasks: Any?) {
    project.getOrCreateAutoGenerateResourcesTask().configure {
        dependsOn(tasks)
    }
}

internal fun Project.createEditorConfigFile(): TaskProvider<Task> {
    val task =
        tasks.register("createEditorConfigFile") {
            group = "build"

            val editorConfigFile = rootProject.file(".editorconfig")
            outputs.file(editorConfigFile)

            doFirst {
                val templateStream =
                    SpecmaticGradlePlugin::class.java.classLoader.getResourceAsStream("editorconfig")
                        ?: throw IllegalStateException("Unable to find editorconfig in classpath")

                editorConfigFile.writeBytes(templateStream.readBytes())
            }
        }

    registerAutoGeneratedResourcesTask(task)

    return task
}

internal fun Project.createVersionPropertiesFileTask(versionInfoForProject: ProjectVersionInfo) {
    val task =
        tasks.register("createVersionPropertiesFile") {
            group = "build"

            inputs.property("projectVersion", versionInfoForProject.toString())
            val versionPropertiesFile = generatedResourcesDir().resolve(versionInfoForProject.propertiesFilePath())
            outputs.file(versionPropertiesFile)

            doLast {
                versionPropertiesFile.parentFile.mkdirs()
                versionPropertiesFile.writeText(versionInfoForProject.toPropertiesFile())
            }
        }

    registerAutoGeneratedResourcesTask(task)
}

internal fun Project.createVersionInfoKotlinTask(versionInfoForProject: ProjectVersionInfo) {
    val task =
        tasks.register("createVersionInfoKotlin") {
            group = "build"
            inputs.property("projectVersion", versionInfoForProject.toString())
            val versionInfoFile = generatedKotlinSourcesDir().resolve(versionInfoForProject.kotlinFilePath())
            outputs.file(versionInfoFile)

            doLast {
                versionInfoFile.parentFile.mkdirs()
                versionInfoFile.writeText(versionInfoForProject.toKotlinClass())
            }
        }

    registerAutoGeneratedKotlinSourceTask(task)
}

internal fun Project.createLogbackXMLFileTask() {
    val task =
        tasks.register("createLogbackXMLResource") {
            group = "build"
            val logbackXMLFile = generatedResourcesDir().resolve("logback.xml")
            outputs.file(logbackXMLFile)
            doLast {
                logbackXMLFile.parentFile.mkdirs()
                val templateStream =
                    SpecmaticGradlePlugin::class.java.classLoader.getResourceAsStream("logback-template.xml")
                        ?: throw IllegalStateException("Unable to find logback-template.xml in classpath")

                logbackXMLFile.writeBytes(templateStream.readBytes())
            }
        }

    registerAutoGeneratedResourcesTask(task)
}

internal fun Project.createJULLogForwarderClassTask() {
    val task =
        tasks.register("createJULForwarderClass") {
            group = "build"
            val julForwarderFile =
                generatedKotlinSourcesDir().resolve(project.kotlinPackageDir()).resolve("JULForwarder.kt")
            outputs.file(julForwarderFile)
            doLast {
                julForwarderFile.parentFile.mkdirs()
                julForwarderFile.writeText(
                    """
                    // $AUTO_GENERATED_CODE_WARNING
                    package ${project.kotlinPackage()}
                    
                    import org.slf4j.bridge.SLF4JBridgeHandler
                    import java.util.logging.LogManager
                    
                    object JULForwarder {
                        fun forward() {
                            LogManager.getLogManager().reset()
                            SLF4JBridgeHandler.removeHandlersForRootLogger()
                            SLF4JBridgeHandler.install()
                        }
                    }
                    """.trimIndent(),
                )
            }
        }

    registerAutoGeneratedKotlinSourceTask(task)
}

private fun Project.getOrCreateAutoGenerateKotlinSourcesTask(): TaskProvider<Task> {
    if (project.tasks.findByName("autoGenerateKotlinSources") != null) {
        return project.tasks.named("autoGenerateKotlinSources")
    }

    val sourcesDir = generatedKotlinSourcesDir()

    val autoGenerateKotlinSources =
        tasks.register("autoGenerateKotlinSources") {
            group = "build"
            description = "Hook to auto-generate sources"
            outputs.dir(sourcesDir)
        }

    plugins.withType(JavaPlugin::class.java) {
        project.extensions.getByType(SourceSetContainer::class.java).named(SourceSet.MAIN_SOURCE_SET_NAME) {
            java {
                srcDir(autoGenerateKotlinSources.map { it.outputs })
            }
        }
    }

    tasks.withType(Delete::class.java) {
        delete(autoGenerateKotlinSources)
    }

    return autoGenerateKotlinSources
}

private fun Project.getOrCreateAutoGenerateResourcesTask(): TaskProvider<Task> {
    if (project.tasks.findByName("autoGenerateResources") != null) {
        return project.tasks.named("autoGenerateResources")
    }

    val resourcesDir = generatedResourcesDir()

    val autoGenerateResources =
        tasks.register("autoGenerateResources") {
            group = "build"
            description = "Hook to auto-generate resources"
            outputs.dir(resourcesDir)
        }

    plugins.withType(JavaPlugin::class.java) {
        project.extensions.getByType(SourceSetContainer::class.java).named(SourceSet.MAIN_SOURCE_SET_NAME) {
            resources {
                srcDir(autoGenerateResources.map { it.outputs })
            }
        }
    }

    tasks.withType(Delete::class.java) {
        delete(resourcesDir)
    }

    return autoGenerateResources
}
